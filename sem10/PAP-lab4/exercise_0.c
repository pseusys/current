/*****************************************************
    AUTHOR  : SÃ©bastien Valat
    MAIL    : sebastien.valat@univ-grenoble-alpes.fr
    LICENSE : BSD
    YEAR    : 2021
    COURSE  : Parallel Algorithms and Programming
*****************************************************/

//////////////////////////////////////////////////////
//
//              DO NOT EDIT THIS FILE
//
// Goal: server as a reference for sequential 
//       implementation.
//
//////////////////////////////////////////////////////

/****************************************************/
#include "src/lbm_struct.h"
#include "src/exercises.h"

/****************************************************/
void lbm_comm_init_ex0(lbm_comm_t * comm, int total_width, int total_height)
{
	//get infos
	int rank;
	int comm_size;
	MPI_Comm_rank( MPI_COMM_WORLD, &rank );
	MPI_Comm_size( MPI_COMM_WORLD, &comm_size );

	//check
	if (comm_size != 1)
		fatal("Invalid communicator size, should be 1 !");

	//comm splitting (just 1 process)
	//nb_* defines the number of task on the given axis.
	comm->nb_x = 1;
	comm->nb_y = 1;

	//positions in the grid
	//rank_* defines the position of the current task in the 2D rank splitting.
	comm->rank_x = 0;
	comm->rank_y = 0;

	//setup size (+2 for ghost cells on border)
	//compute the size of the local mesh, accounting the 1 cell layer of ghost cells.
	comm->width = total_width + 2;
	comm->height = total_height + 2;

	//setup absolute position in global mesh
	//this is required at the init steps to setup the obstacle and border values.
	comm->x = 0;
	comm->y = 0;

	//if debug print comm
	#ifndef NDEBUG
	lbm_comm_print( comm );
	#endif
}

/****************************************************/
void lbm_comm_release_ex0(lbm_comm_t * comm)
{
	//nothing to release
}

/****************************************************/
void lbm_comm_ghost_exchange_ex0(lbm_comm_t * comm, lbm_mesh_t * mesh)
{
	//nothing to exchange (single process, no comms)
}

/****************************************************/
void lbm_do_step_ex0(lbm_comm_t * comm, lbm_mesh_type_t * mesh_type, lbm_mesh_t * mesh, lbm_mesh_t * temp_mesh)
{
	//compute special actions (border, obstacle...)
	lbm_phys_special_cells( mesh, mesh_type, comm);

	//compute lbm_phys_collision term
	lbm_phys_collision( temp_mesh, mesh);

	//propagate values from node to neighboors
	lbm_comm_ghost_exchange_ex_select( comm, temp_mesh );

	//compute fuild displacement from cells to cells
	lbm_phys_propagation( mesh, temp_mesh);
}
